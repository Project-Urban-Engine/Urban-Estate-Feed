<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feed C - Urban Engine</title>
    <style>
        /* ==========================================================================
        Urban Engine – Font Size Scale Reference (px-based)
        기준: Web(Desktop) px → 반응형 축소 매핑
        --------------------------------------------------------------------------
        Web px | Tablet px | Mobile px | Small Mobile px
        --------------------------------------------------------------------------
        44 | 38 | 32 | 26
        38 | 34 | 28 | 24
        28 | 26 | 24 | 20
        24 | 22 | 18 | 16
        22 | 20 | 16 | 14
        20 | 18 | 14 | 13
        18 | 16 | 14 | 13
        16 | 16 | 15 | 14
        15 | 15 | 14 | 13
        14 | 14 | 13 | 13
        13 | 13 | 13 | 13

        Usage rule:
        - Web px 값을 기준으로 선택
        - Tablet / Mobile / Small Mobile은 위 매핑을 그대로 적용
        - clamp(), media query, rem 변환의 기준 테이블로 사용
        ========================================================================== */

        /* Feed A 기준 토큰/브레이크포인트 재활용 */
        @font-face {
            font-family: 'esamanruLight';
            src: url('Source/Fonts/esamanru Light.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'esamanruMedium';
            src: url('Source/Fonts/esamanru Medium.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            --violet: #6f41b0;
            --lightviolet: #9b7ed6;
            --gray: #808080;
            --light-gray: #b3b3b3;
            --black: #111111;
            --white: #f9f9f9;
            --orange: #f7931e;
            --bg: #f6f7f9;

            --pink: #f47db3;
            --blue: #5aa7ff;
            --lightcoral: #f47676;
            --dark: #292929;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'esamanruLight', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: var(--black);
        }

        .page {
            max-width: 1080px;
            margin: 0 auto;
            padding: 50px 50px 80px;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 28px;
        }

        .logo {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 24px;
            color: var(--black);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logo:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .hero {
            margin-top: 120px;
            margin-bottom: 150px;

        }

        .hero small {
            display: block;
            color: var(--gray);
            font-size: 24px;
            margin-bottom: 12px;
        }

        .hero h1 {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 44px;
            line-height: 1.25;
            color: var(--violet);
        }

        .block {
            background-color: var(--white);
            border-radius: 30px;
            padding: 50px 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(17, 17, 17, 0.06);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.06);
            text-align: center;
            transition: all 0.3s ease;
        }

        .block:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .block-title {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .block-sub {
            font-size: 22px;
            color: var(--gray);
        }

        .divider-title {
            margin: 200px 0 50px;
            text-align: center;
            font-family: 'esamanruMedium', sans-serif;
            font-size: 38px;
            color: var(--violet);
        }

        .divider-title.warning {
            color: var(--lightcoral);
        }

        .group {
            display: grid;
            gap: 20px;
        }

        .scale {
            position: relative;
            margin-top: 50px;
            padding: 48px 0 48px;
        }

        .scale-bar {
            height: 30px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--pink) 0%, var(--blue) 100%);
        }

        .marker {
            position: absolute;
            transform: translateX(-50%);
            font-size: 24px;
            color: var(--gray);
            line-height: 1;
            white-space: nowrap;
        }

        .marker.top {
            top: 0;
        }

        .marker.bottom {
            bottom: 0;
        }

        .marker.value::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
        }

        .marker.top.value::after {
            top: 34px;
            border-top: 14px solid #444;
        }

        .marker.bottom.value::after {
            bottom: 34px;
            border-bottom: 14px solid #444;
        }

        .marker.target {
            color: var(--violet);
            font-family: 'esamanruMedium', sans-serif;
        }

        .marker.target.bottom.value::after,
        .marker.target.top.value::after {
            border-top-color: var(--violet);
            border-bottom-color: var(--violet);
        }

        .legend-left {
            left: 0%;
            transform: none;
            text-align: left;
        }

        .legend-right {
            left: 100%;
            transform: translateX(-100%);
            text-align: right;
        }

        .map-section {
            margin-top: 200px;
            width: 100vw;
            margin-left: calc(-50vw + 50%);
            padding: 80px 50px;
            text-align: center;
            background: var(--dark);
        }

        .map-section h3 {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 38px;
            color: var(--white);
            margin-top: 100px;
            margin-bottom: 16px;
        }

        .map-section p {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 28px;
            color: var(--lightviolet);
            margin-bottom: 50px;
        }

        .map-container {
            max-width: 1080px;
            width: 100%;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            border-radius: 28px;
            position: relative;
            overflow: hidden;
            /* box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4), 0 0 40px rgba(111, 65, 176, 0.15); */
        }

        .map-background {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .map-overlay svg {
            width: 100%;
            height: 100%;
        }

        .map-overlay .zone {
            fill: var(--violet);
            fill-opacity: 0.4;
            stroke: var(--violet);
            stroke-width: 10;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: all;
        }

        .map-overlay .zone:hover {
            fill-opacity: 0.7;
            stroke-width: 3;
        }

        /* 태블릿 */
        @media (max-width: 960px) {
            .page {
                padding: 40px 30px 70px;
            }

            .logo {
                font-size: 22px;
            }

            .hero {
                margin-top: 100px;
                margin-bottom: 120px;
            }

            .hero small {
                font-size: 22px;
            }

            .hero h1 {
                font-size: 38px;
            }

            .block {
                border-radius: 26px;
                padding: 42px 26px;
                margin-bottom: 26px;
            }

            .block-title {
                font-size: 26px;
            }

            .block-sub {
                font-size: 20px;
            }

            .divider-title {
                font-size: 34px;
                margin: 160px 0 40px;
            }

            .group {
                gap: 18px;
            }

            .scale {
                margin-top: 42px;
                padding: 40px 0 40px;
            }

            .scale-bar {
                height: 26px;
            }

            .marker {
                font-size: 22px;
            }

            .marker.value::after {
                border-left-width: 9px;
                border-right-width: 9px;
            }

            .marker.top.value::after {
                top: 32px;
                border-top-width: 12px;
            }

            .marker.bottom.value::after {
                bottom: 32px;
                border-bottom-width: 12px;
            }

            .map-section {
                margin-top: 160px;
                width: 100vw;
                margin-left: calc(-50vw + 50%);
                padding: 60px 30px;
            }

            .map-section h3 {
                font-size: 34px;
            }

            .map-section p {
                font-size: 26px;
            }

            .map-container {
                max-width: 960px;
                border-radius: 24px;
            }

            .map-overlay .zone {
                stroke-width: 5px;
            }

            .map-overlay .zone:hover {
                stroke-width: 2.6;
            }
        }

        /* 모바일 */
        @media (max-width: 768px) {
            .page {
                max-width: 420px;
                padding: 24px 20px 60px;
            }

            .logo {
                font-size: 18px;
            }

            .hero {
                margin-top: 80px;
                margin-bottom: 90px;
            }

            .hero small {
                font-size: 18px;
                margin-bottom: 10px;
            }

            .hero h1 {
                font-size: 32px;
            }

            .block {
                border-radius: 24px;
                padding: 36px 20px;
                margin-bottom: 22px;
            }

            .block-title {
                font-size: 24px;
            }

            .block-sub {
                font-size: 16px;
            }

            .divider-title {
                font-size: 28px;
                margin: 120px 0 30px;
            }

            .group {
                gap: 16px;
            }

            .scale {
                margin-top: 36px;
                padding: 32px 0 32px;
            }

            .scale-bar {
                height: 20px;
            }

            .marker {
                font-size: 18px;
            }

            .marker.value::after {
                border-left-width: 7px;
                border-right-width: 7px;
            }

            .marker.top.value::after {
                top: 22px;
                border-top-width: 10px;
            }

            .marker.bottom.value::after {
                bottom: 22px;
                border-bottom-width: 10px;
            }

            .map-section {
                margin-top: 120px;
                width: 100vw;
                margin-left: calc(-50vw + 50%);
                padding: 50px 20px;
            }

            .map-section h3 {
                font-size: 28px;
            }

            .map-section p {
                font-size: 24px;
            }

            .map-container {
                max-width: 420px;
                border-radius: 18px;
            }

            .map-overlay .zone {
                stroke-width: 5px;
            }

            .map-overlay .zone:hover {
                stroke-width: 2.2;
            }
        }

        /* 작은 모바일 */
        @media (max-width: 480px) {
            .page {
                padding: 20px 16px 50px;
            }

            .logo {
                font-size: 16px;
            }

            .hero {
                margin-top: 60px;
                margin-bottom: 70px;
            }

            .hero small {
                font-size: 16px;
            }

            .hero h1 {
                font-size: 26px;
            }

            .block {
                border-radius: 20px;
                padding: 30px 16px;
                margin-bottom: 18px;
            }

            .block-title {
                font-size: 20px;
            }

            .block-sub {
                font-size: 14px;
            }

            .divider-title {
                font-size: 24px;
                margin: 100px 0 24px;
            }

            .group {
                gap: 14px;
            }

            .scale {
                margin-top: 30px;
                padding: 28px 0 28px;
            }

            .scale-bar {
                height: 16px;
            }

            .marker {
                font-size: 16px;
            }

            .marker.value::after {
                border-left-width: 6px;
                border-right-width: 6px;
            }

            .marker.top.value::after {
                top: 20px;
                border-top-width: 8px;
            }

            .marker.bottom.value::after {
                bottom: 20px;
                border-bottom-width: 8px;
            }

            .map-section {
                margin-top: 100px;
                width: 100vw;
                margin-left: calc(-50vw + 50%);
                padding: 40px 16px;
            }

            .map-section h3 {
                font-size: 24px;
            }

            .map-section p {
                font-size: 20px;
            }

            .map-container {
                max-width: 100%;
                border-radius: 16px;
            }

            .map-overlay .zone {
                stroke-width: 5px;
            }

            .map-overlay .zone:hover {
                stroke-width: 1.8;
            }
        }
    </style>
</head>

<body>
    <div class="page">
        <header>
            <div class="logo">Urban Engine</div>
        </header>

        <section class="hero">
            <small id="heroLocation">서울 광진구 자양동</small>
            <h1 id="heroDistrictName">자양로 2길 일대</h1>
        </section>

        <!-- 가격 블록 -->
        <div id="priceBlock"></div>

        <!-- 긍정 블록 -->
        <div id="positiveSection"></div>

        <!-- 부정 블록 -->
        <div id="negativeSection"></div>
    </div>

    <section class="map-section">
        <h3>세부 구역 정보가 더 궁금하다면?</h3>
        <p>아래 구역을 눌러보세요!</p>
        <div class="map-container">
            <img class="map-background" src="" alt="배경 지도">
            <div class="map-overlay" id="zoneOverlay"></div>
        </div>
    </section>

    <script>
        // 구역 ID 및 페르소나 ID (추후 URL 파라미터 등으로 동적 할당)
        const distId = '11215710_021';
        const personaId = 'P01'; // 테스트용

        // 시군구 코드 추출 (dist_id의 앞 5자리)
        const ctyCode = distId.substring(0, 5);

        // 데이터 캐시
        let preferenceVariables = null;
        let preferenceCard = null;
        let prosConsHtype = null;
        let prosConsDist = null;
        let personaPreferences = null;
        let personaTrsType = null;
        let personaHouseType = null;

        // CSV 파싱 함수
        function parseCsv(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            const headers = lines[0].split(',');
            const rows = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] ? values[index].trim() : '';
                });
                rows.push(row);
            }

            return rows;
        }

        // JSON 파싱 헬퍼 (주석 제거)
        async function parseJsonWithComments(response) {
            const text = await response.text();
            // 주석 제거 (// 형태)
            const sanitized = text.replace(/\/\/.*$/gm, '');
            return JSON.parse(sanitized);
        }

        // 데이터 로드 함수들
        async function loadAllData() {
            try {
                console.log('Loading preference variables...');
                const prefVarRes = await fetch('Data/L2.C/C_preference_variables.json');
                preferenceVariables = await parseJsonWithComments(prefVarRes);
                console.log('✓ Preference variables loaded');

                console.log('Loading preference card...');
                const prefCardRes = await fetch('Data/L2.C/C_preference_card.json');
                preferenceCard = await parseJsonWithComments(prefCardRes);
                console.log('✓ Preference card loaded');

                console.log('Loading pros/cons htype...');
                const htypeRes = await fetch(`Data/L2.C/PROS_CONS_TBL/C_${ctyCode}_pros_cons_htype.json`);
                prosConsHtype = await parseJsonWithComments(htypeRes);
                console.log('✓ Pros/cons htype loaded');

                console.log('Loading pros/cons dist...');
                const distRes = await fetch(`Data/L2.C/PROS_CONS_TBL/C_${ctyCode}_pros_cons_dist.json`);
                prosConsDist = await parseJsonWithComments(distRes);
                console.log('✓ Pros/cons dist loaded');

                console.log('Loading persona CSV...');
                const csvRes = await fetch('Source/Persona_1.csv');
                const csvText = await csvRes.text();
                console.log('✓ Persona CSV loaded');
                const parsedCsv = parseCsv(csvText);

                // Persona 정보 추출
                const personaRows = parsedCsv.filter(row => row.persona_id === personaId);
                personaPreferences = {};

                personaRows.forEach(row => {
                    const key = row.preference_key;
                    const priority = parseInt(row.priority, 10) || 0;
                    personaPreferences[key] = {
                        direction: row.direction,
                        priority: priority
                    };

                    // 거래유형과 house_type 저장
                    if (key === 'trs_type') personaTrsType = row.direction;
                    if (key === 'house_type') {
                        const htypeMap = {
                            '단독': 'HS',
                            '다가구': 'HM',
                            '다세대': 'HM',
                            '연립': 'HM',
                            '아파트': 'HA',
                            '오피스텔': 'HO'
                        };
                        personaHouseType = htypeMap[row.direction] || 'HO';
                    }
                });

                console.log('All data loaded successfully');
                console.log('Persona TrsType:', personaTrsType, 'HouseType:', personaHouseType);
                console.log('Persona Preferences:', personaPreferences);

            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        // 변수별 데이터 추출 함수
        function getVariableData(varKey) {
            const varConfig = preferenceVariables.htype[varKey] ||
                preferenceVariables.htype_str[varKey] ||
                preferenceVariables.dist[varKey];

            if (!varConfig) return null;

            const distData = prosConsDist[distId];
            if (!distData) return null;

            let targetValue, entValue;

            // htype 변수 (pros_cons_htype에서 가져오기)
            if (preferenceVariables.htype[varKey]) {
                const htypeData = prosConsHtype[distId];
                if (!htypeData || !htypeData[personaTrsType] || !htypeData[personaTrsType][personaHouseType]) {
                    return null;
                }
                const data = htypeData[personaTrsType][personaHouseType];
                targetValue = data[varConfig + '_pos'];
                entValue = data['ent_' + varConfig + '_pos'];
            }
            // htype_str 또는 dist 변수 (pros_cons_dist에서 가져오기)
            else {
                let fullVarName = varConfig;

                // htype_str인 경우 house type을 변수명에 삽입
                if (preferenceVariables.htype_str[varKey]) {
                    fullVarName = varConfig.replace('HTYPE', personaHouseType);
                }

                targetValue = distData[fullVarName + '_pos'];
                entValue = distData['ent_' + fullVarName + '_pos'];
            }

            // NaN 체크
            if (targetValue === null || entValue === null ||
                isNaN(targetValue) || isNaN(entValue)) {
                return null;
            }

            return {
                key: varKey,
                targetValue: targetValue,
                entValue: entValue,
                diff: targetValue - entValue
            };
        }

        // 긍정/부정 변수 추출 및 정렬
        function extractVariables(isPositive) {
            const allVarKeys = Object.keys({
                ...preferenceVariables.htype,
                ...preferenceVariables.htype_str,
                ...preferenceVariables.dist
            });

            const variables = [];

            allVarKeys.forEach(varKey => {
                const data = getVariableData(varKey);
                if (!data) return;

                // pos 값이 작을수록 좋음: 긍정=diff<0 (target이 더 작음), 부정=diff>0 (target이 더 큼)
                if ((isPositive && data.diff < 0) || (!isPositive && data.diff > 0)) {
                    const priority = personaPreferences[varKey]?.priority || 0;
                    variables.push({
                        ...data,
                        priority: priority,
                        absDiff: Math.abs(data.diff)
                    });
                }
            });

            // 정렬: 1) 우선순위 내림차순, 2) 편차 절대값 내림차순
            variables.sort((a, b) => {
                if (b.priority !== a.priority) {
                    return b.priority - a.priority;
                }
                return b.absDiff - a.absDiff;
            });

            return variables;
        }

        // 카드 블록 생성 함수 (실제 값 연결은 추후)
        function createBlockCard(varKey, isPositive) {
            const cardConfig = preferenceCard[varKey];
            if (!cardConfig) return '';

            const title = isPositive ?
                cardConfig.card_title.positive :
                cardConfig.card_title.negative;

            const legendLeft = cardConfig.bar_legend?.left || '';
            const legendRight = cardConfig.bar_legend?.right || '';

            return `
                <section class="block">
                    <div class="block-title">${title}</div>
                    <div class="block-sub">데이터 연결 예정</div>
                    <div class="scale">
                        ${isPositive ? `<div class="marker top legend-right">${legendRight}</div>` : `<div class="marker top legend-left">${legendLeft}</div>`}
                        <div class="scale-bar"></div>
                        <div class="marker bottom value">시군구 평균</div>
                        <div class="marker bottom value">전체 평균</div>
                        <div class="marker bottom value target">대상지역</div>
                    </div>
                </section>
            `;
        }

        // 페이지 렌더링
        async function renderCards() {
            // 1. 가격 블록 (고정)
            const priceBlock = document.getElementById('priceBlock');
            const priceCard = createBlockCard('price_level', false); // 임시로 부정
            priceBlock.innerHTML = priceCard;

            // 2. 긍정 블록
            const positiveVars = extractVariables(true);
            const top3Positive = positiveVars.slice(0, 3);

            const positiveSection = document.getElementById('positiveSection');
            if (top3Positive.length > 0) {
                let positiveHtml = '<div class="divider-title">왜 이 지역이 좋은가요?</div>';
                positiveHtml += '<div class="group">';
                top3Positive.forEach(varData => {
                    positiveHtml += createBlockCard(varData.key, true);
                });
                positiveHtml += '</div>';
                positiveSection.innerHTML = positiveHtml;
            } else {
                positiveSection.innerHTML = ''; // 좋은 점이 없으면 생략
            }

            // 3. 부정 블록
            const negativeVars = extractVariables(false);
            let selectedNegative = negativeVars.slice(0, 3);

            // 나쁜 점이 0개인 경우, 긍정 중 편차가 작은 것 2개 선택 (중립)
            if (selectedNegative.length === 0) {
                const neutralVars = positiveVars.slice(-2).reverse();
                selectedNegative = neutralVars.map(v => ({ ...v, isNeutral: true }));
            }

            const negativeSection = document.getElementById('negativeSection');
            if (selectedNegative.length > 0) {
                let negativeHtml = '<div class="divider-title warning">어떤 점을 고려해야 하나요?</div>';
                negativeHtml += '<div class="group">';
                selectedNegative.forEach(varData => {
                    // 부정: negative 타이틀, 중립: positive 타이틀
                    const usePositiveTitle = varData.isNeutral || varData.diff < 0;
                    negativeHtml += createBlockCard(varData.key, usePositiveTitle);
                });
                negativeHtml += '</div>';
                negativeSection.innerHTML = negativeHtml;
            }

            console.log('Positive vars:', top3Positive);
            console.log('Negative vars:', selectedNegative);
        }

        // CSV 캐시
        let districtCsvCache = {};

        // CSV 파일에서 구역 정보 가져오기
        async function getDistrictInfo(distId) {
            try {
                const ctyCode = distId.substring(0, 5);

                // 해당 시군구의 CSV가 캐시에 없으면 로드
                if (!districtCsvCache[ctyCode]) {
                    const csvPath = `Data/District/${ctyCode}_dist_nm_desc.csv`;
                    console.log('Loading district CSV:', csvPath);

                    const response = await fetch(csvPath);
                    if (!response.ok) {
                        throw new Error(`Failed to load district CSV: ${csvPath}`);
                    }

                    const csvText = await response.text();
                    districtCsvCache[ctyCode] = parseCsv(csvText);
                    console.log('CSV loaded successfully for:', ctyCode);
                }

                // dist_id로 해당 구역 정보 찾기
                const distInfo = districtCsvCache[ctyCode].find(row => row.dist_id === distId);

                if (!distInfo) {
                    console.warn('District info not found for:', distId);
                    return null;
                }

                return distInfo;
            } catch (error) {
                console.error('Error loading district info:', error);
                return null;
            }
        }

        // Hero 섹션 업데이트
        async function updateHeroSection() {
            const distInfo = await getDistrictInfo(distId);

            if (distInfo) {
                // 동이름: sido_nm + cty_nm + adm_nm
                const locationText = `${distInfo.sido_nm} ${distInfo.cty_nm} ${distInfo.adm_nm}`;
                document.getElementById('heroLocation').textContent = locationText;

                // 구역 명칭: dist_nm
                document.getElementById('heroDistrictName').textContent = distInfo.dist_nm;

                console.log('Hero section updated:', locationText, '-', distInfo.dist_nm);
            } else {
                document.getElementById('heroLocation').textContent = '정보 없음';
                document.getElementById('heroDistrictName').textContent = '구역 정보를 불러올 수 없습니다';
            }
        }

        // SVG 로드 및 삽입
        async function loadZoneMap() {
            try {
                const response = await fetch(`Data/L2.C/ZONE_SVG/${ctyCode}/${distId}_zone_geom.svg`);
                const svgText = await response.text();
                document.getElementById('zoneOverlay').innerHTML = svgText;

                // 구역 클릭 이벤트 추가
                const zones = document.querySelectorAll('.zone');
                zones.forEach(zone => {
                    zone.addEventListener('click', function () {
                        const zoneId = this.getAttribute('data-zone-id');
                        console.log('선택된 구역:', zoneId);
                        // TODO: 구역 상세 정보 표시 또는 페이지 이동
                        alert(`구역 ${zoneId}이 선택되었습니다.\n추후 상세 정보가 표시됩니다.`);
                    });
                });
            } catch (error) {
                console.error('맵 로드 실패:', error);
            }
        }

        // 배경 지도 이미지 업데이트
        function updateBackgroundMap() {
            const mapImage = document.querySelector('.map-background');
            mapImage.src = `Data/L2.C/Background_Map/${ctyCode}/C_${distId}_background_map.png`;
        }

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', async function () {
            await loadAllData();
            await updateHeroSection();
            await renderCards();
            updateBackgroundMap();
            await loadZoneMap();
        });
    </script>
</body>

</html>