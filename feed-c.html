<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feed C - Urban Engine</title>
    <style>
        /* ==========================================================================
        Urban Engine – Font Size Scale Reference (px-based)
        기준: Web(Desktop) px → 반응형 축소 매핑
        --------------------------------------------------------------------------
        Web px | Tablet px | Mobile px | Small Mobile px
        --------------------------------------------------------------------------
        44 | 38 | 32 | 26
        38 | 34 | 28 | 24
        28 | 26 | 24 | 20
        24 | 22 | 18 | 16
        22 | 20 | 16 | 14
        20 | 18 | 14 | 13
        18 | 16 | 14 | 13
        16 | 16 | 15 | 14
        15 | 15 | 14 | 13
        14 | 14 | 13 | 13
        13 | 13 | 13 | 13

        Usage rule:
        - Web px 값을 기준으로 선택
        - Tablet / Mobile / Small Mobile은 위 매핑을 그대로 적용
        - clamp(), media query, rem 변환의 기준 테이블로 사용
        ========================================================================== */

        /* Feed A 기준 토큰/브레이크포인트 재활용 */
        @font-face {
            font-family: 'esamanruLight';
            src: url('Source/Fonts/esamanru Light.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'esamanruMedium';
            src: url('Source/Fonts/esamanru Medium.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            --violet: #6f41b0;
            --lightviolet: #9b7ed6;
            --gray: #808080;
            --light-gray: #b3b3b3;
            --black: #111111;
            --white: #f9f9f9;
            --orange: #f7931e;
            --bg: #f6f7f9;

            --pink: #f47db3;
            --blue: #5aa7ff;
            --lightcoral: #f47676;
            --dark: #292929;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'esamanruLight', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: var(--black);
        }

        .page {
            max-width: 1080px;
            margin: 0 auto;
            padding: 50px 50px 80px;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 28px;
        }

        .logo {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 24px;
            color: var(--black);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logo:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .hero {
            margin-top: 120px;
            margin-bottom: 150px;

        }

        .hero small {
            display: block;
            color: var(--gray);
            font-size: 24px;
            margin-bottom: 12px;
        }

        .hero h1 {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 44px;
            line-height: 1.25;
            color: var(--violet);
        }

        .block {
            background-color: var(--white);
            border-radius: 30px;
            padding: 50px 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(17, 17, 17, 0.06);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.06);
            text-align: center;
            transition: all 0.3s ease;
        }

        .block:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }

        .block-title {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .block-status {
            font-size: 20px;
            color: var(--gray);
            margin-bottom: 8px;
        }

        .block-sub {
            font-size: 22px;
            color: var(--gray);
        }

        .divider-title {
            margin: 200px 0 50px;
            text-align: center;
            font-family: 'esamanruMedium', sans-serif;
            font-size: 38px;
            color: var(--violet);
        }

        .divider-title.warning {
            color: var(--lightcoral);
        }

        .group {
            display: grid;
            gap: 20px;
        }

        .scale {
            position: relative;
            margin-top: 50px;
            padding: 48px 0 48px;
        }

        .scale-bar {
            height: 30px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--pink) 0%, var(--blue) 100%);
        }

        .marker {
            position: absolute;
            transform: translateX(-50%);
            font-size: 24px;
            color: var(--gray);
            line-height: 1;
        }

        .marker-label {
            display: inline-block;
            white-space: nowrap;
            transform: translateX(var(--label-shift, 0px));
            transition: transform 0.2s ease;

        }

        .marker.top {
            top: 0;
        }

        .marker.bottom {
            bottom: 0;
        }

        .marker.value::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
        }

        .marker.top.value::after {
            top: 34px;
            border-top: 14px solid #444;
        }

        .marker.bottom.value::after {
            bottom: 34px;
            border-bottom: 14px solid #444;
        }

        .marker.target {
            color: var(--violet);
            font-family: 'esamanruMedium', sans-serif;
        }

        .marker.target.bottom.value::after,
        .marker.target.top.value::after {
            border-top-color: var(--violet);
            border-bottom-color: var(--violet);
        }

        /* 레전드 레이블 스타일 */
        .scale-legend {
            position: absolute;
            top: 0;
            font-size: 24px;
            color: var(--gray);
            font-family: 'esamanruMedium', sans-serif;
            white-space: nowrap;
            line-height: 1;
        }

        .scale-legend.left {
            left: 0;
            text-align: left;
        }

        .scale-legend.right {
            right: 0;
            text-align: right;
        }

        .map-section {
            margin-top: 200px;
            width: 100vw;
            margin-left: calc(-50vw + 50%);
            padding: 80px 50px;
            text-align: center;
            background: var(--dark);
        }

        .map-section h3 {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 38px;
            color: var(--white);
            margin-top: 100px;
            margin-bottom: 16px;
        }

        .map-section p {
            font-family: 'esamanruMedium', sans-serif;
            font-size: 28px;
            color: var(--lightviolet);
            margin-bottom: 50px;
        }

        .map-container {
            max-width: 1080px;
            width: 100%;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            border-radius: 28px;
            position: relative;
            overflow: hidden;
            /* box-shadow: 0 10px 24px rgba(0, 0, 0, 0.4), 0 0 40px rgba(111, 65, 176, 0.15); */
        }

        .map-background {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .map-overlay svg {
            width: 100%;
            height: 100%;
        }

        .map-overlay .zone {
            fill: var(--violet);
            fill-opacity: 0.4;
            stroke: var(--violet);
            stroke-width: 10;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: all;
        }

        .map-overlay .zone:hover {
            fill-opacity: 0.7;
            stroke-width: 3;
        }

        /* 태블릿 */
        @media (max-width: 960px) {
            .page {
                padding: 40px 30px 70px;
            }

            .logo {
                font-size: 22px;
            }

            .hero {
                margin-top: 100px;
                margin-bottom: 120px;
            }

            .hero small {
                font-size: 22px;
            }

            .hero h1 {
                font-size: 38px;
            }

            .block {
                border-radius: 26px;
                padding: 42px 26px;
                margin-bottom: 26px;
            }

            .block-title {
                font-size: 26px;
            }

            .block-status {
                font-size: 18px;
            }

            .block-sub {
                font-size: 20px;
            }

            .divider-title {
                font-size: 34px;
                margin: 160px 0 40px;
            }

            .group {
                gap: 18px;
            }

            .scale {
                margin-top: 42px;
                padding: 40px 0 40px;
            }

            .scale-bar {
                height: 26px;
            }

            .marker {
                font-size: 22px;
            }

            .scale-legend {
                font-size: 22px;
            }

            .marker.value::after {
                border-left-width: 9px;
                border-right-width: 9px;
            }

            .marker.top.value::after {
                top: 32px;
                border-top-width: 12px;
            }

            .marker.bottom.value::after {
                bottom: 32px;
                border-bottom-width: 12px;
            }

            .map-section {
                margin-top: 160px;
                width: 100vw;
                margin-left: calc(-50vw + 50%);
                padding: 60px 30px;
            }

            .map-section h3 {
                font-size: 34px;
            }

            .map-section p {
                font-size: 26px;
            }

            .map-container {
                max-width: 960px;
                border-radius: 24px;
            }

            .map-overlay .zone {
                stroke-width: 5px;
            }

            .map-overlay .zone:hover {
                stroke-width: 2.6;
            }
        }

        /* 모바일 */
        @media (max-width: 768px) {
            .page {
                max-width: 420px;
                padding: 24px 20px 60px;
            }

            .logo {
                font-size: 18px;
            }

            .hero {
                margin-top: 80px;
                margin-bottom: 90px;
            }

            .hero small {
                font-size: 18px;
                margin-bottom: 10px;
            }

            .hero h1 {
                font-size: 32px;
            }

            .block {
                border-radius: 24px;
                padding: 36px 20px;
                margin-bottom: 22px;
            }

            .block-title {
                font-size: 24px;
            }

            .block-status {
                font-size: 16px;
            }

            .block-sub {
                font-size: 16px;
            }

            .divider-title {
                font-size: 28px;
                margin: 120px 0 30px;
            }

            .group {
                gap: 16px;
            }

            .scale {
                margin-top: 36px;
                padding: 32px 0 32px;
            }

            .scale-bar {
                height: 20px;
            }

            .marker {
                font-size: 18px;
            }

            .scale-legend {
                font-size: 18px;
            }

            .marker.value::after {
                border-left-width: 7px;
                border-right-width: 7px;
            }

            .marker.top.value::after {
                top: 22px;
                border-top-width: 10px;
            }

            .marker.bottom.value::after {
                bottom: 22px;
                border-bottom-width: 10px;
            }

            .map-section {
                margin-top: 120px;
                width: 100vw;
                margin-left: calc(-50vw + 50%);
                padding: 50px 20px;
            }

            .map-section h3 {
                font-size: 28px;
            }

            .map-section p {
                font-size: 24px;
            }

            .map-container {
                max-width: 420px;
                border-radius: 18px;
            }

            .map-overlay .zone {
                stroke-width: 5px;
            }

            .map-overlay .zone:hover {
                stroke-width: 2.2;
            }
        }

        /* 작은 모바일 */
        @media (max-width: 480px) {
            .page {
                padding: 20px 16px 50px;
            }

            .logo {
                font-size: 16px;
            }

            .hero {
                margin-top: 60px;
                margin-bottom: 70px;
            }

            .hero small {
                font-size: 16px;
            }

            .hero h1 {
                font-size: 26px;
            }

            .block {
                border-radius: 20px;
                padding: 30px 16px;
                margin-bottom: 18px;
            }

            .block-title {
                font-size: 20px;
            }

            .block-status {
                font-size: 14px;
            }

            .block-sub {
                font-size: 14px;
            }

            .divider-title {
                font-size: 24px;
                margin: 100px 0 24px;
            }

            .group {
                gap: 14px;
            }

            .scale {
                margin-top: 30px;
                padding: 28px 0 28px;
            }

            .scale-bar {
                height: 16px;
            }

            .marker {
                font-size: 16px;
            }

            .scale-legend {
                font-size: 16px;
            }

            .marker.value::after {
                border-left-width: 6px;
                border-right-width: 6px;
            }

            .marker.top.value::after {
                top: 20px;
                border-top-width: 8px;
            }

            .marker.bottom.value::after {
                bottom: 20px;
                border-bottom-width: 8px;
            }

            .map-section {
                margin-top: 100px;
                width: 100vw;
                margin-left: calc(-50vw + 50%);
                padding: 40px 16px;
            }

            .map-section h3 {
                font-size: 24px;
            }

            .map-section p {
                font-size: 20px;
            }

            .map-container {
                max-width: 100%;
                border-radius: 16px;
            }

            .map-overlay .zone {
                stroke-width: 5px;
            }

            .map-overlay .zone:hover {
                stroke-width: 1.8;
            }
        }
    </style>
</head>

<body>
    <div class="page">
        <header>
            <div class="logo">Urban Engine</div>
        </header>

        <section class="hero">
            <small id="heroLocation">서울 광진구 자양동</small>
            <h1 id="heroDistrictName">자양로 2길 일대</h1>
        </section>

        <!-- 가격 블록 -->
        <div id="priceBlock"></div>

        <!-- 긍정 블록 -->
        <div id="positiveSection"></div>

        <!-- 부정 블록 -->
        <div id="negativeSection"></div>
    </div>

    <section class="map-section">
        <h3>세부 구역 정보가 더 궁금하다면?</h3>
        <p>아래 구역을 눌러보세요!</p>
        <div class="map-container">
            <img class="map-background" src="" alt="배경 지도">
            <div class="map-overlay" id="zoneOverlay"></div>
        </div>
    </section>

    <script>
        // 구역 ID 및 페르소나 ID (추후 URL 파라미터 등으로 동적 할당)
        const distId = '11215710_021';
        const personaId = 'P01'; // 테스트용

        // 시군구 코드 추출 (dist_id의 앞 5자리)
        const ctyCode = distId.substring(0, 5);

        // 데이터 캐시
        let preferenceVariables = null;
        let preferenceCard = null;
        let prosConsHtype = null;
        let prosConsDist = null;
        let personaPreferences = null;
        let personaTrsType = null;
        let personaHouseType = null;

        // CSV 파싱 함수
        function parseCsv(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            const headers = lines[0].split(',');
            const rows = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] ? values[index].trim() : '';
                });
                rows.push(row);
            }

            return rows;
        }

        // JSON 파싱 헬퍼 (주석 제거)
        async function parseJsonWithComments(response) {
            const text = await response.text();
            // 주석 제거 (// 형태)
            const sanitized = text.replace(/\/\/.*$/gm, '');
            return JSON.parse(sanitized);
        }

        // 데이터 로드 함수들
        async function loadAllData() {
            try {
                console.log('Loading preference variables...');
                const prefVarRes = await fetch('Data/L2.C/C_preference_variables.json');
                preferenceVariables = await parseJsonWithComments(prefVarRes);
                console.log('✓ Preference variables loaded');

                console.log('Loading preference card...');
                const prefCardRes = await fetch('Data/L2.C/C_preference_card.json');
                preferenceCard = await parseJsonWithComments(prefCardRes);
                console.log('✓ Preference card loaded');

                console.log('Loading pros/cons htype...');
                const htypeRes = await fetch(`Data/L2.C/PROS_CONS_TBL/C_${ctyCode}_pros_cons_htype.json`);
                prosConsHtype = await parseJsonWithComments(htypeRes);
                console.log('✓ Pros/cons htype loaded');

                console.log('Loading pros/cons dist...');
                const distRes = await fetch(`Data/L2.C/PROS_CONS_TBL/C_${ctyCode}_pros_cons_dist.json`);
                prosConsDist = await parseJsonWithComments(distRes);
                console.log('✓ Pros/cons dist loaded');

                console.log('Loading persona CSV...');
                const csvRes = await fetch('Source/Persona_1.csv');
                const csvText = await csvRes.text();
                console.log('✓ Persona CSV loaded');
                const parsedCsv = parseCsv(csvText);

                // Persona 정보 추출
                const personaRows = parsedCsv.filter(row => row.persona_id === personaId);
                personaPreferences = {};

                personaRows.forEach(row => {
                    const key = row.preference_key;
                    const priority = parseInt(row.priority, 10) || 0;
                    personaPreferences[key] = {
                        direction: row.direction,
                        priority: priority
                    };

                    // 거래유형과 house_type 저장
                    if (key === 'trs_type') personaTrsType = row.direction;
                    if (key === 'house_type') {
                        const htypeMap = {
                            '단독': 'HS',
                            '다가구': 'HM',
                            '다세대': 'HM',
                            '연립': 'HM',
                            '아파트': 'HA',
                            '오피스텔': 'HO'
                        };
                        personaHouseType = htypeMap[row.direction] || 'HO';
                    }
                });

                console.log('All data loaded successfully');
                console.log('Persona TrsType:', personaTrsType, 'HouseType:', personaHouseType);
                console.log('Persona Preferences:', personaPreferences);

            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        // 변수별 데이터 추출 함수
        function getVariableData(varKey) {
            const varConfig = preferenceVariables.htype[varKey] ||
                preferenceVariables.htype_str[varKey] ||
                preferenceVariables.dist[varKey];

            if (!varConfig) {
                console.warn(`[${varKey}] Variable config not found`);
                return null;
            }

            const distData = prosConsDist[distId];
            if (!distData) {
                console.warn(`[${varKey}] District data not found for distId: ${distId}`);
                return null;
            }

            let targetValue, entValue, ctyValue;

            // htype 변수 (pros_cons_htype에서 가져오기)
            if (preferenceVariables.htype[varKey]) {
                const htypeData = prosConsHtype[distId];
                if (!htypeData || !htypeData[personaTrsType] || !htypeData[personaTrsType][personaHouseType]) {
                    console.warn(`[${varKey}] Htype data not found - TrsType: ${personaTrsType}, HouseType: ${personaHouseType}`);
                    return null;
                }
                const data = htypeData[personaTrsType][personaHouseType];
                targetValue = data[varConfig + '_pos'];
                entValue = data['ent_' + varConfig + '_pos'];

                // cty 값: htypeData에 있으면 사용, 없으면 distData에서
                ctyValue = data['cty_' + varConfig + '_pos'];
                if (ctyValue === undefined || ctyValue === null || isNaN(ctyValue)) {
                    ctyValue = distData['cty_' + varConfig + '_pos'];
                }
                console.log(`[${varKey}] From htype - target: ${targetValue}, ent: ${entValue}, cty: ${ctyValue}`);
            }
            // htype_str 또는 dist 변수 (pros_cons_dist에서 가져오기)
            else {
                let fullVarName = varConfig;

                // htype_str인 경우 house type을 변수명에 삽입
                if (preferenceVariables.htype_str[varKey]) {
                    fullVarName = varConfig.replace('HTYPE', personaHouseType);
                }

                targetValue = distData[fullVarName + '_pos'];
                entValue = distData['ent_' + fullVarName + '_pos'];
                ctyValue = distData['cty_' + fullVarName + '_pos'];
                console.log(`[${varKey}] From dist - fullVarName: ${fullVarName}, target: ${targetValue}, ent: ${entValue}, cty: ${ctyValue}`);
            }

            // NaN 체크
            if (targetValue === null || entValue === null || ctyValue === null ||
                isNaN(targetValue) || isNaN(entValue) || isNaN(ctyValue)) {
                console.warn(`[${varKey}] Invalid values - target: ${targetValue}, ent: ${entValue}, cty: ${ctyValue}`);
                return null;
            }

            // _pct 값 가져오기
            let targetValuePct = null;
            if (preferenceVariables.htype[varKey]) {
                // htype 변수: htypeData에서 먼저 시도, 없으면 distData에서
                const htypeData = prosConsHtype[distId];
                if (htypeData && htypeData[personaTrsType] && htypeData[personaTrsType][personaHouseType]) {
                    const data = htypeData[personaTrsType][personaHouseType];
                    targetValuePct = data[varConfig + '_pct'];
                    // htypeData에 없으면 distData에서
                    if (targetValuePct === undefined || targetValuePct === null) {
                        targetValuePct = distData[varConfig + '_pct'];
                    }
                }
            } else {
                let fullVarName = varConfig;
                if (preferenceVariables.htype_str[varKey]) {
                    fullVarName = varConfig.replace('HTYPE', personaHouseType);
                }
                targetValuePct = distData[fullVarName + '_pct'];
            }
            console.log(`[${varKey}] targetValuePct: ${targetValuePct}`);

            return {
                key: varKey,
                targetValue: targetValue,
                entValue: entValue,
                ctyValue: ctyValue,
                targetValuePct: targetValuePct,
                diff: targetValue - entValue
            };
        }

        // 긍정/부정 변수 추출 및 정렬
        function extractVariables(isPositive) {
            const allVarKeys = Object.keys({
                ...preferenceVariables.htype,
                ...preferenceVariables.htype_str,
                ...preferenceVariables.dist
            });

            const variables = [];

            allVarKeys.forEach(varKey => {
                // price_level은 메인 블록에서 별도로 표시하므로 제외
                if (varKey === 'price_level') return;

                const data = getVariableData(varKey);
                if (!data) return;

                // pos 값이 클수록 좋음 (1에 가까울수록 긍정적): 긍정=diff>0 (target이 더 큼), 부정=diff<0 (target이 더 작음)
                if ((isPositive && data.diff > 0) || (!isPositive && data.diff < 0)) {
                    // 부정 항목일 때: targetValue가 0.65 이상(좋음 이상)이면 제외
                    if (!isPositive && data.targetValue >= 0.65) {
                        console.log(`[${varKey}] ⛔ Excluded from negative: targetValue=${data.targetValue.toFixed(3)} >= 0.65 (diff=${data.diff.toFixed(3)})`);
                        return;
                    }

                    if (!isPositive) {
                        console.log(`[${varKey}] ✅ Included in negative: targetValue=${data.targetValue.toFixed(3)} < 0.65 (diff=${data.diff.toFixed(3)})`);
                    }

                    const priority = personaPreferences[varKey]?.priority || 0;
                    variables.push({
                        ...data,
                        priority: priority,
                        absDiff: Math.abs(data.diff)
                    });
                }
            });

            // 정렬: 1) 우선순위 내림차순, 2) 편차 절대값 내림차순
            variables.sort((a, b) => {
                if (b.priority !== a.priority) {
                    return b.priority - a.priority;
                }
                return b.absDiff - a.absDiff;
            });

            return variables;
        }

        // 점수 범위에 따른 상태 텍스트 매핑
        const scoreRanges = [
            { min: 0.85, max: 1.00, text: '최고' },
            { min: 0.65, max: 0.85, text: '좋음' },
            { min: 0.35, max: 0.65, text: '보통' },
            { min: 0.15, max: 0.35, text: '다소 나쁨' },
            { min: 0.00, max: 0.15, text: '나쁨' }
        ];

        function getScoreLabel(score) {
            if (score === null || score === undefined || isNaN(score)) return '보통';

            for (const range of scoreRanges) {
                if (score >= range.min && score < range.max) {
                    return range.text;
                }
                // 마지막 범위 (1.00 포함)
                if (range.max === 1.00 && score === 1.00) {
                    return range.text;
                }
            }
            return '보통';
        }

        // 카드 블록 생성 함수
        function createBlockCard(varKey, isPositive, varData = null) {
            const cardConfig = preferenceCard[varKey];
            if (!cardConfig) return '';

            const title = isPositive ?
                cardConfig.card_title.positive :
                cardConfig.card_title.negative;

            const legendLeft = cardConfig.bar_legend?.left || '';
            const legendRight = cardConfig.bar_legend?.right || '';

            // 상태 정보 생성
            let statusHtml = '';
            if (varData && varData.targetValue !== null && varData.targetValuePct !== null) {
                const statusText = getScoreLabel(varData.targetValue);
                // 100-pct로 계산 (예: 98 -> 상위 2%)
                const pctValue = Math.round(100 - varData.targetValuePct);
                const rankText = pctValue <= 50 ? '상위' : '하위';
                statusHtml = `<div class="block-status">${statusText} | ${rankText} ${pctValue}%</div>`;
            }

            // 마커 위치 및 상/하단 배치
            let markersHtml = '';
            if (varData) {
                // 3개 마커의 pos 값과 레이블
                const markers = [
                    { pos: varData.targetValue, label: '대상지역', class: 'target' },
                    { pos: varData.ctyValue, label: '시군구 평균', class: '' },
                    { pos: varData.entValue, label: '전체 평균', class: '' }
                ];

                // pos 값으로 정렬
                const sortedMarkers = markers.sort((a, b) => a.pos - b.pos);

                // 상/하단 번갈아 배치 (하단-상단-하단)
                const positions = ['bottom', 'top', 'bottom'];

                markersHtml = sortedMarkers.map((marker, index) => {
                    const position = positions[index];
                    const leftPercent = (marker.pos * 100).toFixed(1);
                    return `<div class="marker ${position} value ${marker.class}" style="left: ${leftPercent}%;" data-pos="${marker.pos}"><span class="marker-label">${marker.label}</span></div>`;
                }).join('');
            } else {
                // 데이터가 없을 때 기본 마커 (위치 없음)
                markersHtml = `
                    <div class="marker bottom value"><span class="marker-label">시군구 평균</span></div>
                    <div class="marker bottom value"><span class="marker-label">전체 평균</span></div>
                    <div class="marker bottom value target"><span class="marker-label">대상지역</span></div>
                `;
            }

            return `
                <section class="block">
                    <div class="block-title">${title}</div>
                    ${statusHtml}
                    <div class="block-sub">${varData ? '' : '데이터 연결 예정'}</div>
                    <div class="scale">
                        <div class="scale-legend left">${legendLeft}</div>
                        <div class="scale-legend right">${legendRight}</div>
                        <div class="scale-bar"></div>
                        ${markersHtml}
                    </div>
                </section>
            `;
        }

        // 마커 라벨 겹침 해결 함수
        function resolveAllMarkerLabels() {
            const scales = document.querySelectorAll('.scale');

            scales.forEach(scale => {
                const bar = scale.querySelector('.scale-bar');
                if (!bar) return;

                const barRect = bar.getBoundingClientRect();
                const markers = Array.from(scale.querySelectorAll('.marker.value'));

                if (markers.length === 0) return;

                const topMarkers = markers.filter(m => m.classList.contains('top'));
                const bottomMarkers = markers.filter(m => m.classList.contains('bottom'));

                // 레전드 라벨 정보 수집 (TOP 위치에 존재)
                const legendLabels = Array.from(scale.querySelectorAll('.scale-legend'))
                    .map(legend => {
                        const rect = legend.getBoundingClientRect();
                        const isLeft = legend.classList.contains('left');
                        return {
                            left: rect.left,
                            right: rect.right,
                            width: rect.width,
                            isLeft: isLeft  // true면 왼쪽(나쁨), false면 오른쪽(좋음)
                        };
                    })
                    .filter(r => r !== null);

                // TOP 마커는 레전드와의 충돌 체크 필요
                resolveGroupCollisions(topMarkers, barRect, legendLabels);
                // BOTTOM 마커는 레전드와 충돌하지 않음
                resolveGroupCollisions(bottomMarkers, barRect, []);
            });
        }

        function resolveGroupCollisions(markers, barRect, legendLabels = []) {
            if (markers.length === 0) return;

            const GAP = 10;
            const PADDING = 5;
            const STEP = 20;
            const ITERATIONS = 15;

            // 화면상 x 위치로 정렬
            markers.sort((a, b) => {
                const posA = parseFloat(a.dataset.pos || '0');
                const posB = parseFloat(b.dataset.pos || '0');
                return posA - posB;
            });

            // 각 마커의 정보 및 허용 shift 범위 계산
            const markerData = markers.map(m => {
                const label = m.querySelector('.marker-label');
                if (!label) return null;

                const pos = parseFloat(m.dataset.pos);
                if (isNaN(pos)) return null;

                const labelRect = label.getBoundingClientRect();
                const centerX = barRect.left + (barRect.width * pos);
                const halfWidth = labelRect.width / 2;

                // 라벨이 bar 안에 완전히 들어오도록 하는 shift 범위
                const minShift = (barRect.left + PADDING) - centerX + halfWidth;
                const maxShift = (barRect.right - PADDING) - centerX - halfWidth;

                return {
                    marker: m,
                    label: label,
                    centerX: centerX,
                    labelWidth: labelRect.width,
                    shift: 0,
                    minShift: minShift,
                    maxShift: maxShift
                };
            }).filter(d => d !== null);

            if (markerData.length === 0) return;

            // Relaxation: 충돌을 반복적으로 해소
            for (let iter = 0; iter < ITERATIONS; iter++) {
                let hasCollision = false;

                // 1) 마커 간 충돌 처리
                if (markerData.length >= 2) {
                    for (let i = 0; i < markerData.length - 1; i++) {
                        const dataA = markerData[i];
                        const dataB = markerData[i + 1];

                        // 현재 shift를 반영한 라벨의 좌우 위치
                        const aLeft = dataA.centerX + dataA.shift - dataA.labelWidth / 2;
                        const aRight = dataA.centerX + dataA.shift + dataA.labelWidth / 2;
                        const bLeft = dataB.centerX + dataB.shift - dataB.labelWidth / 2;

                        // 충돌 감지
                        const overlap = aRight + GAP - bLeft;

                        if (overlap > 0) {
                            hasCollision = true;

                            // 각 마커가 이동할 수 있는 여유 공간 계산
                            const aLeftRoom = dataA.shift - dataA.minShift;  // A가 왼쪽으로 더 갈 수 있는 거리
                            const bRightRoom = dataB.maxShift - dataB.shift; // B가 오른쪽으로 더 갈 수 있는 거리

                            // 이동량 결정: 각자가 갈 수 있는 만큼 비율로 배분
                            const totalRoom = aLeftRoom + bRightRoom;

                            if (totalRoom > 0) {
                                const moveAmount = Math.min(STEP, overlap);

                                // 비율로 배분
                                const aRatio = aLeftRoom / totalRoom;
                                const bRatio = bRightRoom / totalRoom;

                                const aMoveLeft = moveAmount * aRatio;
                                const bMoveRight = moveAmount * bRatio;

                                dataA.shift -= aMoveLeft;
                                dataB.shift += bMoveRight;
                            } else {
                                // 둘 다 여유가 없으면 최선을 다함
                                dataA.shift -= Math.min(STEP / 2, aLeftRoom);
                                dataB.shift += Math.min(STEP / 2, bRightRoom);
                            }

                            // 개별 범위로 clamp (매 스텝마다)
                            dataA.shift = Math.max(dataA.minShift, Math.min(dataA.maxShift, dataA.shift));
                            dataB.shift = Math.max(dataB.minShift, Math.min(dataB.maxShift, dataB.shift));
                        }
                    }
                }

                // 2) 레전드 라벨과의 충돌 처리
                if (legendLabels.length > 0) {
                    for (let i = 0; i < markerData.length; i++) {
                        const data = markerData[i];
                        const markerLeft = data.centerX + data.shift - data.labelWidth / 2;
                        const markerRight = data.centerX + data.shift + data.labelWidth / 2;

                        for (const legendRect of legendLabels) {
                            // 레전드와 마커의 겹침 확인
                            const overlapWithLegend = !(markerRight + GAP <= legendRect.left || markerLeft >= legendRect.right + GAP);

                            if (overlapWithLegend) {
                                hasCollision = true;

                                // 왼쪽 레전드(나쁨) → 마커를 오른쪽으로 밀기
                                if (legendRect.isLeft) {
                                    const requiredShift = (legendRect.right + GAP) - markerLeft;
                                    if (requiredShift > 0) {
                                        const moveRight = Math.min(STEP, requiredShift);
                                        const rightRoom = data.maxShift - data.shift;
                                        data.shift += Math.min(moveRight, rightRoom);
                                    }
                                }
                                // 오른쪽 레전드(좋음) → 마커를 왼쪽으로 밀기
                                else {
                                    const requiredShift = markerRight - (legendRect.left - GAP);
                                    if (requiredShift > 0) {
                                        const moveLeft = Math.min(STEP, requiredShift);
                                        const leftRoom = data.shift - data.minShift;
                                        data.shift -= Math.min(moveLeft, leftRoom);
                                    }
                                }

                                // 범위로 clamp
                                data.shift = Math.max(data.minShift, Math.min(data.maxShift, data.shift));
                            }
                        }
                    }
                }

                // 더 이상 충돌이 없으면 조기 종료
                if (!hasCollision) break;
            }

            // 최종 적용 (이미 clamp되어 있음)
            markerData.forEach(data => {
                data.label.style.setProperty('--label-shift', `${data.shift}px`);
            });
        }

        // 페이지 렌더링
        async function renderCards() {
            // 1. 가격 블록 (고정)
            const priceBlock = document.getElementById('priceBlock');
            const priceData = getVariableData('price_level');
            console.log('Price data:', priceData);
            // 모든 변수는 1에 가까울수록 좋게 정렬됨: diff > 0이면 긍정, diff < 0이면 부정
            const isPricePositive = priceData && priceData.diff > 0;
            const priceCard = createBlockCard('price_level', isPricePositive, priceData);
            priceBlock.innerHTML = priceCard;

            // 2. 긍정 블록
            const positiveVars = extractVariables(true);
            const top3Positive = positiveVars.slice(0, 3);

            const positiveSection = document.getElementById('positiveSection');
            if (top3Positive.length > 0) {
                let positiveHtml = '<div class="divider-title">왜 이 지역이 좋은가요?</div>';
                positiveHtml += '<div class="group">';
                top3Positive.forEach(varData => {
                    positiveHtml += createBlockCard(varData.key, true, varData);
                });
                positiveHtml += '</div>';
                positiveSection.innerHTML = positiveHtml;
            } else {
                positiveSection.innerHTML = ''; // 좋은 점이 없으면 생략
            }

            // 3. 부정 블록
            const negativeVars = extractVariables(false);
            let selectedNegative = negativeVars.slice(0, 3);

            // 긍정에 이미 사용된 변수 키 저장
            const usedPositiveKeys = new Set(top3Positive.map(v => v.key));

            // 부정 요소가 2개 미만인 경우, 긍정 중 편차가 작은 것으로 채워서 최소 2개 확보 (중립)
            if (selectedNegative.length < 2) {
                const needed = 2 - selectedNegative.length;
                // 중립 후보: targetValue < 0.65이고 긍정에 사용되지 않은 항목만 선택
                const neutralCandidates = positiveVars.filter(v =>
                    v.targetValue < 0.65 && !usedPositiveKeys.has(v.key)
                );
                const neutralVars = neutralCandidates.slice(-needed).reverse();
                const neutralWithFlag = neutralVars.map(v => ({ ...v, isNeutral: true }));
                selectedNegative = [...selectedNegative, ...neutralWithFlag];
                console.log('Neutral vars added:', neutralVars.map(v => `${v.key}(${v.targetValue.toFixed(3)})`));
            }

            const negativeSection = document.getElementById('negativeSection');
            if (selectedNegative.length > 0) {
                let negativeHtml = '<div class="divider-title warning">어떤 점을 고려해야 하나요?</div>';
                negativeHtml += '<div class="group">';
                selectedNegative.forEach(varData => {
                    // 부정 섹션에서는 중립 요소도 negative 타이틀 사용
                    negativeHtml += createBlockCard(varData.key, false, varData);
                });
                negativeHtml += '</div>';
                negativeSection.innerHTML = negativeHtml;
            }

            console.log('Positive vars:', top3Positive);
            console.log('Negative vars:', selectedNegative);

            requestAnimationFrame(() => {
                resolveAllMarkerLabels();
            });
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resolveAllMarkerLabels();
            }, 200);
        });

        // CSV 캐시
        let districtCsvCache = {};

        // CSV 파일에서 구역 정보 가져오기
        async function getDistrictInfo(distId) {
            try {
                const ctyCode = distId.substring(0, 5);

                // 해당 시군구의 CSV가 캐시에 없으면 로드
                if (!districtCsvCache[ctyCode]) {
                    const csvPath = `Data/District/${ctyCode}_dist_nm_desc.csv`;
                    console.log('Loading district CSV:', csvPath);

                    const response = await fetch(csvPath);
                    if (!response.ok) {
                        throw new Error(`Failed to load district CSV: ${csvPath}`);
                    }

                    const csvText = await response.text();
                    districtCsvCache[ctyCode] = parseCsv(csvText);
                    console.log('CSV loaded successfully for:', ctyCode);
                }

                // dist_id로 해당 구역 정보 찾기
                const distInfo = districtCsvCache[ctyCode].find(row => row.dist_id === distId);

                if (!distInfo) {
                    console.warn('District info not found for:', distId);
                    return null;
                }

                return distInfo;
            } catch (error) {
                console.error('Error loading district info:', error);
                return null;
            }
        }

        // Hero 섹션 업데이트
        async function updateHeroSection() {
            const distInfo = await getDistrictInfo(distId);

            if (distInfo) {
                // 동이름: sido_nm + cty_nm + adm_nm
                const locationText = `${distInfo.sido_nm} ${distInfo.cty_nm} ${distInfo.adm_nm}`;
                document.getElementById('heroLocation').textContent = locationText;

                // 구역 명칭: dist_nm
                document.getElementById('heroDistrictName').textContent = distInfo.dist_nm;

                console.log('Hero section updated:', locationText, '-', distInfo.dist_nm);
            } else {
                document.getElementById('heroLocation').textContent = '정보 없음';
                document.getElementById('heroDistrictName').textContent = '구역 정보를 불러올 수 없습니다';
            }
        }

        // SVG 로드 및 삽입
        async function loadZoneMap() {
            try {
                const response = await fetch(`Data/L2.C/ZONE_SVG/${ctyCode}/${distId}_zone_geom.svg`);
                const svgText = await response.text();
                document.getElementById('zoneOverlay').innerHTML = svgText;

                // 구역 클릭 이벤트 추가
                const zones = document.querySelectorAll('.zone');
                zones.forEach(zone => {
                    zone.addEventListener('click', function () {
                        const zoneId = this.getAttribute('data-zone-id');
                        console.log('선택된 구역:', zoneId);
                        // TODO: 구역 상세 정보 표시 또는 페이지 이동
                        alert(`구역 ${zoneId}이 선택되었습니다.\n추후 상세 정보가 표시됩니다.`);
                    });
                });
            } catch (error) {
                console.error('맵 로드 실패:', error);
            }
        }

        // 배경 지도 이미지 업데이트
        function updateBackgroundMap() {
            const mapImage = document.querySelector('.map-background');
            mapImage.src = `Data/L2.C/Background_Map/${ctyCode}/C_${distId}_background_map.png`;
        }

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', async function () {
            await loadAllData();
            await updateHeroSection();
            await renderCards();
            updateBackgroundMap();
            await loadZoneMap();
        });
    </script>
</body>

</html>